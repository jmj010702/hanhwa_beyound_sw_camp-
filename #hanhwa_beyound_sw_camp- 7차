# BEYOND SW 캠프 23기 — 7주차 회고

## 📚 Findings — 무엇을 배웠나?

### 1. 힙(Heap)과 힙 정렬
- 배열 기반 **완전 이진 트리** 구조  
  - 부모 i → 왼쪽 2i+1, 오른쪽 2i+2 *(0-based 인덱스 기준, 확실함)*
- `heapify`를 재귀적으로 적용해 힙 구성
- **루트 ↔ 마지막 원소 교환 후 범위 축소**를 반복하는 힙 정렬 구조
- `PriorityQueue`는 **힙 기반 자료구조**이며  
  `add`, `poll`의 평균 시간복잡도는 **O(log n)** *(확실함)*

**풀이 문제**
- 프로그래머스: 명예의 전당
- 프로그래머스: 야근 지수

---

### 2. DFS & BFS
- 그래프를 **인접 리스트**로 표현
- 방문 배열 `visited`의 위치 차이:
  - DFS: 재귀 호출 **전에** 방문 체크
  - BFS: 큐에 **넣기 전에(enqueue)** 방문 체크  
- BFS는 **최단 거리 계산**에 사용 가능 *(가중치 없는 그래프 기준, 확실함)*

**풀이 문제**
- 백준 1260: DFS와 BFS  
- 백준 2210: 숫자판 점프  
- 백준 11724: 연결 요소의 개수  
- 백준 11725: 트리의 부모 찾기  
- 백준 1697: 숨바꼭질  
- 백준 2644: 촌수 계산  
- 프로그래머스: 게임 맵 최단거리  
- 프로그래머스: 가장 먼 노드  
- 프로그래머스: 피로도 (완전탐색 + 백트래킹)

---

### 3. 그리디(Greedy)
- 문제 해결 흐름  
  1) 정렬 기준 정의  
  2) 탐욕적 선택 규칙 적용  
  3) 항상 최적해가 되는지 검증  
- 예: **동전 거스름돈 문제**는 특정 조건(정규 화폐 체계)에서만 항상 최적해  
  *(일반적인 화폐 체계에서는 성립하지 않을 수 있음 — 확실하지 않음)*

**풀이 문제**
- 백준 1449: 수리공 항승  
- 프로그래머스: 체육복  

---

### 4. 동적 계획법(DP)
- 설계 순서  
  → 상태 정의 → 점화식 → 초기값 → 계산 순서
- 구현 방식  
  - Top-down (메모이제이션)  
  - Bottom-up (테이블 채우기)

**풀이 문제**
- 프로그래머스: 멀리 뛰기  
- 백준 2579: 계단 오르기  
- 백준 2294: 동전 2  
- 백준 1149: RGB 거리  
- 프로그래머스: 정수 삼각형  
- 백준 2096: 내려가기  
- 백준 11053: 가장 긴 증가하는 부분 수열  
- 백준 14002: LIS 4  
- 백준 12865: 평범한 배낭  
- 백준 14725: 벼락치기  
- 백준 1106: 호텔  

---

### 5. 투 포인터(Two Pointer)
- 정렬된 배열에서  
  `start`, `end` 포인터를 이동시키며  
  **합·차 조건으로 범위를 축소**
- 시간복잡도: **O(n)** *(정렬 제외, 확실함)*
- 슬라이딩 윈도우는 고정 길이 구간 합을 다루는 방식으로 목적이 다름 *(확실함)*

**풀이 문제**
- 백준 3273: 두 수의 합  
- 백준 2470: 두 용액  
- 백준 2230: 수 고르기  
- 백준 2559: 수열  
- 프로그래머스: 연속된 부분 수열의 합  
- 백준 2003: 수들의 합 2  
- 프로그래머스: 숫자의 표현  

---

### 6. 이분 탐색(Binary Search)
- **정렬된 배열**에서만 사용 가능
- `mid` 비교 후 탐색 범위를 절반씩 축소
- 시간복잡도: **O(log n)** *(확실함)*
- `lower bound`, `upper bound` 등 **경계값 탐색** 가능

**풀이 문제**
- 백준 2512: 예산  
- 백준 16401: 과자 나눠주기  
- 백준 3079: 입국심사  

---

## 🧠 Feelings — 어떻게 느꼈나?
알고리즘의 유형과 언제 어떤 알고리즘을 사용해야 하는지를 느낄 수 있었고,  
문제 유형이 생각보다 훨씬 다양하다는 점을 체감했다.  
알고리즘은 감각을 유지하는 것이 중요하다고 느껴 꾸준한 문제 풀이가 필요하다고 생각했다.

---

## 🔮 Future — 다음에 어떻게 활용할까?
문제 풀이 시 시간 복잡도를 계속 계산하며 더 효율적인 방향을 고민할 것이다.  
특히 BFS, DFS는 다익스트라 알고리즘의 기반이 되므로  
최단 거리 추천 시스템 같은 서비스 구현에도 활용할 수 있을 것이라 생각했다.

---

## ✏️ 마무리 한 줄
가장 어려운 주였지만, 포기하고 싶을 때 문제를 해결했을 때의 성취감이 너무 좋아  
앞으로도 계속 알고리즘 문제를 풀어가고 싶다.
